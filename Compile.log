[GenMod] CurFunc: <null Function>, CurBlock: <null BasicBlock>, CurIP: {<invalid IP>} - Entering generateModule. isEntryPoint=true
[GenMod] CurFunc: <null Function>, CurBlock: <null BasicBlock>, CurIP: {<invalid IP>} - Module resources initialized (runtime functions, global ctor).
[GenMod] CurFunc: <null Function>, CurBlock: <null BasicBlock>, CurIP: {<invalid IP>} - [EntryPt] Processing as entry point module.
[GenMod] CurFunc: <null Function>, CurBlock: <null BasicBlock>, CurIP: {<invalid IP>} - [EntryPt] Got entry function: __llvmpy_entry
[GenMod] CurFunc: <null Function>, CurBlock: <null BasicBlock>, CurIP: {<invalid IP>} - [EntryPt] Created new entry block for __llvmpy_entry: entry
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Set initial insert point in __llvmpy_entry.
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Set current function to __llvmpy_entry. Saved context: Func=<null Function>, IP=Block: entry, Point: end
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Starting statement loop in __llvmpy_entry. Initial block: entry
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Loop Iter: Processing Stmt Kind 24 at line 9 in block entry
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Entering handleFunctionDefStmt for Python func 'main'
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Defining FunctionAST 'main' in current symbol table scope.
Debug [PyScope]: Defined FunctionAST 'main' in this scope.
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Calling ModuleGen->handleFunctionDef for 'main'...
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Entering handleFunctionDef for Python func 'main'
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Generated unique LLVM name: 'main.L9.C5' for Python name 'main'
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Saving context...
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Saved IP: {Block: entry, Point: end}, Saved Func: __llvmpy_entry
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Resolving return and param types for 'main'...
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Resolved return type: int
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Resolved param types: []
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Creating LLVM function type and function using unique name 'main.L9.C5'...
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Got LLVM function: main.L9.C5 with name 'main.L9.C5'
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Added/Updated functionCache for AST node 94694178197952 -> LLVM Func main.L9.C5
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Setting up entry block and params for 'main.L9.C5'...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Set insert point to new entry block: entry
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Set current function to: main.L9.C5
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Scope pushed. Depth: 3. Handling params...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Params handled. Generating body stmts...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Body: Handling Stmt Kind 24 at line 6
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Entering handleFunctionDefStmt for Python func 'test'
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Defining FunctionAST 'test' in current symbol table scope.
Debug [PyScope]: Defined FunctionAST 'test' in this scope.
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Calling ModuleGen->handleFunctionDef for 'test'...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Entering handleFunctionDef for Python func 'test'
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Generated unique LLVM name: 'test.L6.C5' for Python name 'test'
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Saving context...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Saved IP: {Block: entry, Point: end}, Saved Func: main.L9.C5
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Resolving return and param types for 'test'...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Resolved return type: int
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Resolved param types: [int]
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Creating LLVM function type and function using unique name 'test.L6.C5'...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Got LLVM function: test.L6.C5 with name 'test.L6.C5'
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Added/Updated functionCache for AST node 94694178196944 -> LLVM Func test.L6.C5
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Setting up entry block and params for 'test.L6.C5'...
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Set insert point to new entry block: entry
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Set current function to: test.L6.C5
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Scope pushed. Depth: 4. Handling params...
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Params handled. Generating body stmts...
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Body: Handling Stmt Kind 5 at line 4
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Body: Handling Stmt Kind 5 at line 5
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Body: Handling Stmt Kind 4 at line 6
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Finished handling body stmts. Popping scope...
Debug [PySymbolTable]: Skipping cleanups for scope level 4 (block terminated or invalid).
Debug [PySymbolTable]: Popping scope level 4
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Checking for default return for 'test.L6.C5'. Last block: entry
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - No default return needed (block already terminated).
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Cleaning up function resources for 'test.L6.C5'...
[HdlFuncDef] CurFunc: test.L6.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Restoring context. Target IP: {Block: entry, Point: end}, Target Func: main.L9.C5
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Restored IP.
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Context restored. Current function: main.L9.C5
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Verifying function 'test.L6.C5'...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Function verification PASSED for 'test.L6.C5'.
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: entry, CurIP: {Block: entry, Point: end} - Leaving handleFunctionDef for 'test' (LLVM: test.L6.C5)
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - ModuleGen->handleFunctionDef SUCCEEDED for 'test'. Got LLVM Func: define internal ptr @test.L6.C5(ptr %a) {
entry:
  call void @py_print_object(ptr %a)
  %str_obj = call ptr @py_create_string(ptr @str_const)
  call void @py_print_object(ptr %str_obj)
  %int_obj_from_str = call ptr @py_create_int_bystring(ptr @int_str_const, i32 10)
  ret ptr %int_obj_from_str
}
 ('test.L6.C5')
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Calling TypeGen->getFunctionObjectType for 'test'...
Debug [CodeGenType]: Resolved static FunctionType for 'test' as func
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - TypeGen->getFunctionObjectType SUCCEEDED for 'test'. Type: func
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Calling RuntimeGen->createFunctionObject using LLVM func 'test.L6.C5'...
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - RuntimeGen->createFunctionObject SUCCEEDED for 'test'. Value:   %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Function 'test' is nested. Looking for/Creating AllocaInst.
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - No existing variable/AllocaInst found for 'test'. Creating new AllocaInst.
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Created new AllocaInst for 'test':   %test.addr = alloca ptr, align 8
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
  %test.old = load ptr, ptr %test.addr, align 8
  %isOldValueNotNull = icmp ne ptr %test.old, null
  br i1 %isOldValueNotNull, label %decRefOldFunc, label %storeNewFunc

decRefOldFunc:                                    ; preds = %entry
  call void @py_decref(ptr %test.old)
  br label %storeNewFunc

storeNewFunc:                                     ; preds = %decRefOldFunc, %entry
  store ptr %new_py_func_obj, ptr %test.addr, align 8
}
, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Stored PyObject* (  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)) into AllocaInst:   %test.addr = alloca ptr, align 8 in block entry
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
  %test.old = load ptr, ptr %test.addr, align 8
  %isOldValueNotNull = icmp ne ptr %test.old, null
  br i1 %isOldValueNotNull, label %decRefOldFunc, label %storeNewFunc

decRefOldFunc:                                    ; preds = %entry
  call void @py_decref(ptr %test.old)
  br label %storeNewFunc

storeNewFunc:                                     ; preds = %decRefOldFunc, %entry
  store ptr %new_py_func_obj, ptr %test.addr, align 8
  call void @py_incref(ptr %new_py_func_obj)
}
, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - IncRef'd new PyObject* (  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)) for nested function storage.
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
  %test.old = load ptr, ptr %test.addr, align 8
  %isOldValueNotNull = icmp ne ptr %test.old, null
  br i1 %isOldValueNotNull, label %decRefOldFunc, label %storeNewFunc

decRefOldFunc:                                    ; preds = %entry
  call void @py_decref(ptr %test.old)
  br label %storeNewFunc

storeNewFunc:                                     ; preds = %decRefOldFunc, %entry
  store ptr %new_py_func_obj, ptr %test.addr, align 8
  call void @py_incref(ptr %new_py_func_obj)
}
, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Binding/Rebinding SymbolTable entry for 'test' to storage:   %test.addr = alloca ptr, align 8
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
  %test.old = load ptr, ptr %test.addr, align 8
  %isOldValueNotNull = icmp ne ptr %test.old, null
  br i1 %isOldValueNotNull, label %decRefOldFunc, label %storeNewFunc

decRefOldFunc:                                    ; preds = %entry
  call void @py_decref(ptr %test.old)
  br label %storeNewFunc

storeNewFunc:                                     ; preds = %decRefOldFunc, %entry
  store ptr %new_py_func_obj, ptr %test.addr, align 8
  call void @py_incref(ptr %new_py_func_obj)
}
, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - SymbolTable binding confirmed/updated for 'test'.
[HdlFuncDefStmt] CurFunc: define internal ptr @main.L9.C5() {
entry:
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
  %test.old = load ptr, ptr %test.addr, align 8
  %isOldValueNotNull = icmp ne ptr %test.old, null
  br i1 %isOldValueNotNull, label %decRefOldFunc, label %storeNewFunc

decRefOldFunc:                                    ; preds = %entry
  call void @py_decref(ptr %test.old)
  br label %storeNewFunc

storeNewFunc:                                     ; preds = %decRefOldFunc, %entry
  store ptr %new_py_func_obj, ptr %test.addr, align 8
  call void @py_incref(ptr %new_py_func_obj)
}
, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Leaving handleFunctionDefStmt for 'test'
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Body: Handling Stmt Kind 6 at line 6
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Body: Handling Stmt Kind 5 at line 8
[HdlCallExpr] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Generating runtime call via py_call_function for 'func'
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Body: Handling Stmt Kind 4 at line 8
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Finished handling body stmts. Popping scope...
Debug [PySymbolTable]: Skipping cleanups for scope level 3 (block terminated or invalid).
Debug [PySymbolTable]: Popping scope level 3
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Checking for default return for 'main.L9.C5'. Last block: storeNewFunc
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - No default return needed (block already terminated).
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Cleaning up function resources for 'main.L9.C5'...
[HdlFuncDef] CurFunc: main.L9.C5, CurBlock: storeNewFunc, CurIP: {Block: storeNewFunc, Point: end} - Restoring context. Target IP: {Block: entry, Point: end}, Target Func: __llvmpy_entry
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Restored IP.
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Context restored. Current function: __llvmpy_entry
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Verifying function 'main.L9.C5'...
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Function verification PASSED for 'main.L9.C5'.
[HdlFuncDef] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - Leaving handleFunctionDef for 'main' (LLVM: main.L9.C5)
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - ModuleGen->handleFunctionDef SUCCEEDED for 'main'. Got LLVM Func: define internal ptr @main.L9.C5() {
entry:
  %callargs_array = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  %test.addr = alloca ptr, align 8
  %new_py_func_obj = call ptr @py_create_function(ptr @test.L6.C5, i32 8)
  %test.old = load ptr, ptr %test.addr, align 8
  %isOldValueNotNull = icmp ne ptr %test.old, null
  br i1 %isOldValueNotNull, label %decRefOldFunc, label %storeNewFunc

decRefOldFunc:                                    ; preds = %entry
  call void @py_decref(ptr %test.old)
  br label %storeNewFunc

storeNewFunc:                                     ; preds = %decRefOldFunc, %entry
  store ptr %new_py_func_obj, ptr %test.addr, align 8
  call void @py_incref(ptr %new_py_func_obj)
  %test_val = load ptr, ptr %test.addr, align 8
  store ptr %test_val, ptr %func.addr, align 8
  call void @py_incref(ptr %test_val)
  %func_callable_loaded = load ptr, ptr %func.addr, align 8
  %int_obj_from_str = call ptr @py_create_int_bystring(ptr @int_str_const.1, i32 10)
  call void @py_incref(ptr %int_obj_from_str)
  %arg_ptr_0 = getelementptr ptr, ptr %callargs_array, i32 0
  store ptr %int_obj_from_str, ptr %arg_ptr_0, align 8
  %call_result = call ptr @py_call_function(ptr %func_callable_loaded, i32 1, ptr %callargs_array)
  call void @py_print_object(ptr %call_result)
  %int_obj_from_str1 = call ptr @py_create_int_bystring(ptr @int_str_const.2, i32 10)
  ret ptr %int_obj_from_str1
}
 ('main.L9.C5')
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Calling TypeGen->getFunctionObjectType for 'main'...
Debug [CodeGenType]: Resolved static FunctionType for 'main' as func
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - TypeGen->getFunctionObjectType SUCCEEDED for 'main'. Type: func
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Calling RuntimeGen->createFunctionObject using LLVM func 'main.L9.C5'...
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - RuntimeGen->createFunctionObject SUCCEEDED for 'main'. Value:   %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Function 'main' is top-level. Looking for/Creating GlobalVariable.
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Created GlobalVariable: @main_obj_gv = internal global ptr null in Module@ 94694178208080
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
  store ptr %new_py_func_obj, ptr @main_obj_gv, align 8
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Stored PyObject* into GlobalVariable: @main_obj_gv = internal global ptr null in block entry
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
  store ptr %new_py_func_obj, ptr @main_obj_gv, align 8
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Binding/Rebinding SymbolTable entry for 'main' to storage: @main_obj_gv = internal global ptr null
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
  store ptr %new_py_func_obj, ptr @main_obj_gv, align 8
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - SymbolTable binding confirmed/updated for 'main'.
[HdlFuncDefStmt] CurFunc: define i32 @__llvmpy_entry() {
entry:
  %new_py_func_obj = call ptr @py_create_function(ptr @main.L9.C5, i32 8)
  store ptr %new_py_func_obj, ptr @main_obj_gv, align 8
}
, CurBlock: entry, CurIP: {Block: entry, Point: end} - Leaving handleFunctionDefStmt for 'main'
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Loop Iter: After handleStmt. Current block: entry
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Preparing to call Python main. Current block: entry
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Looking up GlobalVariable 'main_obj_gv' in Module@ 94694178208080
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Found Python main function GlobalVariable: @main_obj_gv = internal global ptr null
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Loaded 'main' object:   %main_func_loaded = load ptr, ptr @main_obj_gv, align 8
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Generated call to Python main. Result object:   %call_result = call ptr @py_call_function_noargs(ptr %main_func_loaded)
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Generated conversion to exit code:   %exit_code = call i32 @py_object_to_exit_code(ptr %call_result)
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Added return instruction for exit code.
Debug [PySymbolTable]: Skipping cleanups for scope level 2 (block terminated or invalid).
Debug [PySymbolTable]: Popping scope level 2
[GenMod] CurFunc: __llvmpy_entry, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Finished statement loop and main call sequence.
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Restored context. Current function: <null Function>, IP=Block: entry, Point: end
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Verifying entry function '__llvmpy_entry'...
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - [EntryPt] Entry function verification PASSED.
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - Verifying entire module...
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - Module verification PASSED.
[GenMod] CurFunc: <null Function>, CurBlock: entry, CurIP: {Block: entry, Point: end} - Leaving generateModule.
成功将 /home/ljs/code/llvmpy/test.py 编译为 output.ll
