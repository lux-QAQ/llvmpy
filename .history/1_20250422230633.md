看起来问题出在函数调用时查找函数定义的方式上。错误日志显示在 `handleCallExpr` 中查找 `func_fib` 失败，即使符号表 dump 显示 `func_fib` 的 `FunctionAST` 定义存在于父作用域 (Level 2)。

这通常意味着 `handleCallExpr` 的查找逻辑不完整。它似乎只检查了符号表中的**变量**，而没有检查**函数 AST 定义**。

以下是建议的修改：

1.  **修改 `CodeGenExpr::handleCallExpr` 以查找 FunctionAST**：
    在 `handleCallExpr` 中，当按变量名查找失败后，不应立即报错，而应尝试查找同名的 `FunctionAST` 定义。如果找到，则获取对应的 LLVM 函数和类型信息，并加载其运行时表示（通常是存储在全局变量中的函数对象）。

    ```cpp
    // filepath: /home/ljs/code/llvmpy/src/CodeGen/CodeGenExpr.cpp
    // ... inside handleCallExpr ...
    
        // 2. 检查 calleeName 是否是符号表中的变量
        if (symTable.hasVariable(calleeName))
        {
            llvm::Value* varValue = symTable.getVariable(calleeName);
            ObjectType* objType = symTable.getVariableType(calleeName);
            callableType = objType ? PyType::fromObjectType(objType) : PyType::getAny();
    
            // 2.1. 加载变量的值 (可能是全局变量或局部变量)
            if (auto* gv = llvm::dyn_cast<llvm::GlobalVariable>(varValue))
            {
                // Load from global variable (like top-level function objects)
                callableObj = builder.CreateLoad(gv->getValueType(), gv, calleeName + "_callable_loaded");
            }
            else if (auto* allocaInst = llvm::dyn_cast<llvm::AllocaInst>(varValue))
            {
                // Load from local variable (alloca)
                callableObj = builder.CreateLoad(allocaInst->getAllocatedType(), allocaInst, calleeName + "_callable_loaded");
            }
            else
            {
                // Assume it's already a direct value (e.g., PyObject* for nested funcs, though less common here)
                callableObj = varValue;
            }
    
            // 2.2. 检查类型是否可调用
            if (!callableType->isFunction() && !callableType->isAny())
            {
                return codeGen.logTypeError("Variable '" + calleeName + "' is not callable.",
                                            expr->line.value_or(0), expr->column.value_or(0));
            }
        }
        // --- MODIFICATION START: Add FunctionAST lookup ---
        else
        {
            // 2.5. 如果不是变量，尝试查找是否为已定义的 FunctionAST
            const FunctionAST* funcAST = symTable.findFunctionAST(calleeName);
            if (funcAST)
            {
    #ifdef DEBUG_CODEGEN_handleCallExpr // Add debug log if needed
                DEBUG_LOG_DETAIL("HdlCallExpr", "Found FunctionAST for '" + calleeName + "' in symbol table.");
    #endif
                // 2.5.1. 获取对应的 LLVM 函数 (从 CodeGenModule 缓存中查找)
                FunctionDefInfo* funcInfo = codeGen.getModuleGen()->getFunctionInfo(calleeName);
                llvm::Function* llvmFunc = funcInfo ? funcInfo->function : nullptr;
    
                if (!llvmFunc) {
                     // 如果在缓存中找不到，可能意味着 handleFunctionDefStmt 失败或逻辑错误
                     return codeGen.logError("Found FunctionAST for '" + calleeName + "' but failed to get corresponding LLVM function from cache.",
                                             expr->line.value_or(0), expr->column.value_or(0));
                }
    
                // 2.5.2. 获取函数类型信息
                ObjectType* funcObjType = codeGen.getTypeGen()->getFunctionObjectType(funcAST); // Get ObjectType
                if (!funcObjType || funcObjType->getCategory() != ObjectType::Function) {
                     return codeGen.logError("Found FunctionAST for '" + calleeName + "' but failed to get valid ObjectType.",
                                             expr->line.value_or(0), expr->column.value_or(0));
                }
                callableType = PyType::fromObjectType(funcObjType); // Convert to PyType
    
                // 2.5.3. 加载运行时函数对象 (通常从全局变量加载)
                // 假设顶层函数对象存储在名为 <funcName>_obj_gv 的全局变量中
                std::string gvName = calleeName + "_obj_gv";
                llvm::GlobalVariable* funcObjGV = codeGen.getModule()->getGlobalVariable(gvName);
    
                if (funcObjGV) {
                     callableObj = builder.CreateLoad(funcObjGV->getValueType(), funcObjGV, calleeName + "_callable_loaded_from_ast");
    #ifdef DEBUG_CODEGEN_handleCallExpr
                     DEBUG_LOG_DETAIL("HdlCallExpr", "Loaded callable object for '" + calleeName + "' from GlobalVariable: " + llvmObjToString(callableObj));
    #endif
                } else {
                     // 如果找不到全局变量，这是一个错误，表明 handleFunctionDefStmt 未能正确存储函数对象
                     return codeGen.logError("Found FunctionAST for '" + calleeName + "' but could not find its GlobalVariable '" + gvName + "'. Function definition might be incomplete.",
                                             expr->line.value_or(0), expr->column.value_or(0));
                }
            }
            else
            {
                 // --- MODIFICATION: Print symbol table on lookup failure ---
                 std::cerr << "--- Symbol Table Dump (Variable and AST Lookup Failed for '" << calleeName << "') ---" << std::endl;
                 symTable.dump(std::cerr); // Assuming PySymbolTable has a dump method
                 std::cerr << "---------------------------------------------------------" << std::endl;
                 // --- End Modification ---
    
                 // 3. 如果变量和 AST 都找不到，才报错
                 return codeGen.logError("Unknown function or variable: " + calleeName,
                                         expr->line.value_or(0), expr->column.value_or(0));
            }
        }
        // --- MODIFICATION END ---
    
        if (!callableObj)
        {
            // 如果前面的逻辑未能解析 callableObj，则报错
            return codeGen.logError("Could not resolve callable expression: " + calleeName,
                                    expr->line.value_or(0), expr->column.value_or(0));
        }
    
        // --- MODIFICATION END ---
    
        // 4. 生成参数的代码 (与之前类似)
    // ... rest of the function call generation ...
    ````

2.  **调整 `CodeGenModule::handleFunctionDef` 中处理参数的时机**：
    为了确保函数参数变量和函数体内的局部变量位于正确的作用域（函数内部作用域），`handleFunctionParams` 应该在 `stmtGen->beginScope()` **之后** 调用。

    ```cpp
    // filepath: /home/ljs/code/llvmpy/src/CodeGen/CodeGenModule.cpp
    llvm::Function* CodeGenModule::handleFunctionDef(const FunctionAST* funcAST) // 接受 const*
    {
        // ... (保存上下文, 解析类型, 创建 LLVM 函数) ...
    
        // --- 函数是新创建的或为空，继续生成 ---
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Function is new or empty. Generating body...");
    #endif
        llvm::BasicBlock* entryBB = createFunctionEntry(function);
        if (!entryBB) { /* ... 处理错误 ... */ return nullptr; }
    
        codeGen.getBuilder().SetInsertPoint(entryBB);
        codeGen.setCurrentFunction(function);
        codeGen.setCurrentReturnType(returnType->getObjectType());
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Set insert point and current function context.");
    #endif
    
        // --- 生成函数体 ---
        auto* stmtGen = codeGen.getStmtGen();
        stmtGen->beginScope(); // <--- Push scope FIRST
    
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Scope pushed. Depth: " + std::to_string(codeGen.getSymbolTable().getCurrentScopeDepth()) + ". Handling params...");
    #endif
        // Ensure getParams() is const
        handleFunctionParams(function, funcAST->getParams(), paramTypes); // <--- Handle params AFTER pushing scope
    
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Params handled. Generating body stmts...");
    #endif
        // Ensure getBody() is const
        for (const auto& stmt : funcAST->getBody())
        {
            // Check if the current block is already terminated (e.g., by a previous return)
            if (!codeGen.getBuilder().GetInsertBlock() || codeGen.getBuilder().GetInsertBlock()->getTerminator()) {
    #ifdef DEBUG_CODEGEN_handleFunctionDef
                DEBUG_LOG_DETAIL("HdlFuncDef", "Current block terminated before handling stmt. Skipping rest of body.");
    #endif
                break; // Stop processing statements in this block
            }
            stmtGen->handleStmt(stmt.get());
        }
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Finished handling body stmts. Popping scope...");
    #endif
        stmtGen->endScope(); // <--- Pop scope AFTER body generation
    
        // --- 添加默认返回 (如果需要) ---
        // ... (检查并添加默认返回) ...
    
        // --- 清理函数资源 ---
        // ... (cleanupFunction) ...
    
        // --- 恢复之前的上下文 ---
        // ... (恢复上下文) ...
    
        // --- 验证生成的函数 ---
        // ... (验证函数) ...
    
        return function;
    }
    ````

应用这些更改后，`handleCallExpr` 应该能够正确找到并调用在父作用域中定义的函数 `func_fib`，并且符号表的作用域结构应该更加清晰。// filepath: /home/ljs/code/llvmpy/src/CodeGen/CodeGenExpr.cpp
    // ... inside handleCallExpr ...
    
        // 2. 检查 calleeName 是否是符号表中的变量
        if (symTable.hasVariable(calleeName))
        {
            llvm::Value* varValue = symTable.getVariable(calleeName);
            ObjectType* objType = symTable.getVariableType(calleeName);
            callableType = objType ? PyType::fromObjectType(objType) : PyType::getAny();
    
            // 2.1. 加载变量的值 (可能是全局变量或局部变量)
            if (auto* gv = llvm::dyn_cast<llvm::GlobalVariable>(varValue))
            {
                // Load from global variable (like top-level function objects)
                callableObj = builder.CreateLoad(gv->getValueType(), gv, calleeName + "_callable_loaded");
            }
            else if (auto* allocaInst = llvm::dyn_cast<llvm::AllocaInst>(varValue))
            {
                // Load from local variable (alloca)
                callableObj = builder.CreateLoad(allocaInst->getAllocatedType(), allocaInst, calleeName + "_callable_loaded");
            }
            else
            {
                // Assume it's already a direct value (e.g., PyObject* for nested funcs, though less common here)
                callableObj = varValue;
            }
    
            // 2.2. 检查类型是否可调用
            if (!callableType->isFunction() && !callableType->isAny())
            {
                return codeGen.logTypeError("Variable '" + calleeName + "' is not callable.",
                                            expr->line.value_or(0), expr->column.value_or(0));
            }
        }
        // --- MODIFICATION START: Add FunctionAST lookup ---
        else
        {
            // 2.5. 如果不是变量，尝试查找是否为已定义的 FunctionAST
            const FunctionAST* funcAST = symTable.findFunctionAST(calleeName);
            if (funcAST)
            {
    #ifdef DEBUG_CODEGEN_handleCallExpr // Add debug log if needed
                DEBUG_LOG_DETAIL("HdlCallExpr", "Found FunctionAST for '" + calleeName + "' in symbol table.");
    #endif
                // 2.5.1. 获取对应的 LLVM 函数 (从 CodeGenModule 缓存中查找)
                FunctionDefInfo* funcInfo = codeGen.getModuleGen()->getFunctionInfo(calleeName);
                llvm::Function* llvmFunc = funcInfo ? funcInfo->function : nullptr;
    
                if (!llvmFunc) {
                     // 如果在缓存中找不到，可能意味着 handleFunctionDefStmt 失败或逻辑错误
                     return codeGen.logError("Found FunctionAST for '" + calleeName + "' but failed to get corresponding LLVM function from cache.",
                                             expr->line.value_or(0), expr->column.value_or(0));
                }
    
                // 2.5.2. 获取函数类型信息
                ObjectType* funcObjType = codeGen.getTypeGen()->getFunctionObjectType(funcAST); // Get ObjectType
                if (!funcObjType || funcObjType->getCategory() != ObjectType::Function) {
                     return codeGen.logError("Found FunctionAST for '" + calleeName + "' but failed to get valid ObjectType.",
                                             expr->line.value_or(0), expr->column.value_or(0));
                }
                callableType = PyType::fromObjectType(funcObjType); // Convert to PyType
    
                // 2.5.3. 加载运行时函数对象 (通常从全局变量加载)
                // 假设顶层函数对象存储在名为 <funcName>_obj_gv 的全局变量中
                std::string gvName = calleeName + "_obj_gv";
                llvm::GlobalVariable* funcObjGV = codeGen.getModule()->getGlobalVariable(gvName);
    
                if (funcObjGV) {
                     callableObj = builder.CreateLoad(funcObjGV->getValueType(), funcObjGV, calleeName + "_callable_loaded_from_ast");
    #ifdef DEBUG_CODEGEN_handleCallExpr
                     DEBUG_LOG_DETAIL("HdlCallExpr", "Loaded callable object for '" + calleeName + "' from GlobalVariable: " + llvmObjToString(callableObj));
    #endif
                } else {
                     // 如果找不到全局变量，这是一个错误，表明 handleFunctionDefStmt 未能正确存储函数对象
                     return codeGen.logError("Found FunctionAST for '" + calleeName + "' but could not find its GlobalVariable '" + gvName + "'. Function definition might be incomplete.",
                                             expr->line.value_or(0), expr->column.value_or(0));
                }
            }
            else
            {
                 // --- MODIFICATION: Print symbol table on lookup failure ---
                 std::cerr << "--- Symbol Table Dump (Variable and AST Lookup Failed for '" << calleeName << "') ---" << std::endl;
                 symTable.dump(std::cerr); // Assuming PySymbolTable has a dump method
                 std::cerr << "---------------------------------------------------------" << std::endl;
                 // --- End Modification ---
    
                 // 3. 如果变量和 AST 都找不到，才报错
                 return codeGen.logError("Unknown function or variable: " + calleeName,
                                         expr->line.value_or(0), expr->column.value_or(0));
            }
        }
        // --- MODIFICATION END ---
    
        if (!callableObj)
        {
            // 如果前面的逻辑未能解析 callableObj，则报错
            return codeGen.logError("Could not resolve callable expression: " + calleeName,
                                    expr->line.value_or(0), expr->column.value_or(0));
        }
    
        // --- MODIFICATION END ---
    
        // 4. 生成参数的代码 (与之前类似)
    // ... rest of the function call generation ...
    ````

2.  **调整 `CodeGenModule::handleFunctionDef` 中处理参数的时机**：
    为了确保函数参数变量和函数体内的局部变量位于正确的作用域（函数内部作用域），`handleFunctionParams` 应该在 `stmtGen->beginScope()` **之后** 调用。

    ```cpp
    // filepath: /home/ljs/code/llvmpy/src/CodeGen/CodeGenModule.cpp
    llvm::Function* CodeGenModule::handleFunctionDef(const FunctionAST* funcAST) // 接受 const*
    {
        // ... (保存上下文, 解析类型, 创建 LLVM 函数) ...
    
        // --- 函数是新创建的或为空，继续生成 ---
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Function is new or empty. Generating body...");
    #endif
        llvm::BasicBlock* entryBB = createFunctionEntry(function);
        if (!entryBB) { /* ... 处理错误 ... */ return nullptr; }
    
        codeGen.getBuilder().SetInsertPoint(entryBB);
        codeGen.setCurrentFunction(function);
        codeGen.setCurrentReturnType(returnType->getObjectType());
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Set insert point and current function context.");
    #endif
    
        // --- 生成函数体 ---
        auto* stmtGen = codeGen.getStmtGen();
        stmtGen->beginScope(); // <--- Push scope FIRST
    
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Scope pushed. Depth: " + std::to_string(codeGen.getSymbolTable().getCurrentScopeDepth()) + ". Handling params...");
    #endif
        // Ensure getParams() is const
        handleFunctionParams(function, funcAST->getParams(), paramTypes); // <--- Handle params AFTER pushing scope
    
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Params handled. Generating body stmts...");
    #endif
        // Ensure getBody() is const
        for (const auto& stmt : funcAST->getBody())
        {
            // Check if the current block is already terminated (e.g., by a previous return)
            if (!codeGen.getBuilder().GetInsertBlock() || codeGen.getBuilder().GetInsertBlock()->getTerminator()) {
    #ifdef DEBUG_CODEGEN_handleFunctionDef
                DEBUG_LOG_DETAIL("HdlFuncDef", "Current block terminated before handling stmt. Skipping rest of body.");
    #endif
                break; // Stop processing statements in this block
            }
            stmtGen->handleStmt(stmt.get());
        }
    #ifdef DEBUG_CODEGEN_handleFunctionDef
        DEBUG_LOG_DETAIL("HdlFuncDef", "Finished handling body stmts. Popping scope...");
    #endif
        stmtGen->endScope(); // <--- Pop scope AFTER body generation
    
        // --- 添加默认返回 (如果需要) ---
        // ... (检查并添加默认返回) ...
    
        // --- 清理函数资源 ---
        // ... (cleanupFunction) ...
    
        // --- 恢复之前的上下文 ---
        // ... (恢复上下文) ...
    
        // --- 验证生成的函数 ---
        // ... (验证函数) ...
    
        return function;
    }
    ````

应用这些更改后，`handleCallExpr` 应该能够正确找到并调用在父作用域中定义的函数 `func_fib`，并且符号表的作用域结构应该更加清晰。